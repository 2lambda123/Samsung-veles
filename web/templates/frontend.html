<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="img/veles.png" />
    <title>VELES Command Line Frontend</title>
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap-switch.min.css" rel="stylesheet">
    <link href="css/frontend.css" rel="stylesheet" type="text/css" />
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    </head>
    <body>
        <div id="command-line-container" class="input-group">
            <span class="input-group-btn">
            <button type="button" class="btn btn-success" onclick="run()">RUN</button>
            </span>
            <input type="text" class="form-control standalone master slave" id="command-line">
        </div>
        <div class="alert alert-danger" id="error-message" role="alert">
          <strong>Warning!</strong> Better check yourself, you're not looking too good.
        </div>
        <div id="arguments">
            <div class="panel panel-primary argument master slave standalone">
                <div class="panel-heading master slave standalone">
                  <span class="label label-danger argtype">Mandatory</span>
                  <h3 class="panel-title">Mode</h3>
                </div>
                <div class="panel-body">
                    <div class="pull-right description">
                      <p>Selects VELES operation mode. Standalone is the best choice for debugging workflows and relatively small tasks. Master mode runs VELES workflow server which accepts slaves. Slave mode is the headless VELES instance which requests jobs from a master and returns results.</p>
                    </div>
                    <div class="dropdown">
                      <button class="btn btn-default dropdown-toggle master slave standalone" type="button" id="dropdownMode" data-toggle="dropdown">
                        Standalone
                        <span class="caret"></span>
                      </button>
                      <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMode">
                        <li role="presentation"><a role="menuitem" tabindex="-1" href="#" onclick="select_mode('Standalone')">Standalone</a></li>
                        <li role="presentation"><a role="menuitem" tabindex="-1" href="#" onclick="select_mode('Master')">Master</a></li>
                        <li role="presentation"><a role="menuitem" tabindex="-1" href="#" onclick="select_mode('Slave')">Slave</a></li>
                      </ul>
                    </div>
                </div>
            </div>
            {% raw arguments %}
        </div>
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="js/jquery.min.js"></script>
        <!-- Include all compiled plugins (below), or include individual files as needed -->
        <script src="js/bootstrap.min.js"></script>
        <script src="js/bootstrap-switch.min.js"></script>
        <script src="js/typeahead.min.js"></script>
        <script src="js/minimist.min.js"></script>

        <script>
          var opts = {% raw opts %};
          var alias_reversed = {};

          for (var key in opts.alias) {
            alias_reversed[opts.alias[key]] = key;
          }

          initial_disable();

          var substringMatcher = function(strs) {
            return function findMatches(q, cb) {
              var matches, substrRegex;
              matches = [];
              substrRegex = new RegExp(q, 'i');
              $.each(strs, function(i, str) {
                if (substrRegex.test(str)) {
                  matches.push({ value: str });
                }
              });
              cb(matches);
            };
          };

          var workflows = {% raw workflows %};

          var cmdline_states = {% raw cmdline_states %};

          $('.typeahead').typeahead({
            hint: true,
            highlight: true,
            minLength: 1
          },
          {
            name: 'workflows',
            displayKey: 'value',
            source: substringMatcher(workflows)
          });

          function disable(mode) {
            $(".argument:not(." + mode + ")").addClass("disabled");
            $(".panel-heading:not(." + mode + ")").addClass("disabled");
            $(".form-control:not(." + mode + ")").attr("disabled", "disabled");
            $(".switch:not(." + mode + ")").bootstrapSwitch('disabled', true);
            $(".dropdown-toggle:not(." + mode + ")").attr("disabled", "disabled");
          };

          function enable_all() {
            $(".argument").removeClass("disabled");
            $(".panel-heading").removeClass("disabled");
            $(".form-control").removeAttr("disabled", "disabled");
            $(".switch").bootstrapSwitch('disabled', false);
            $(".dropdown-toggle").removeAttr("disabled", "disabled");
          };

          function initial_disable() {
            common_mode = $("#dropdownMode").text().trim();
            common_mode = common_mode.toLowerCase();
            disable(common_mode);
          }

          function select_mode(mode) {
            $("#dropdownMode").get(0).firstChild.nodeValue = mode + " ";
            mode = mode.toLowerCase();
            enable_all();
            disable(mode);
            var cl = $("#command-line").val().replace(/\s+/, " ");
            var args = parse_cl(cl);
            var states = from_args_to_states(args, states);
            $.each(states, function(opt, arg) {
              var elem_opt = $("#" + opt);
              if (!elem_opt.hasClass(mode)) {
                delete cmdline_states[opt];
                cl = cl.replace(opt + " " + arg, "");
                cl = cl.replace(opt, "");
              }
            });
            elem.val(cl);
            $("#command-line").trigger("change");
          }

          function select(choice, id) {
            $("#dropdown_menu" + id).get(0).firstChild.nodeValue = choice + " ";
            choice = choice.toLowerCase();
            var id = id;
            var value = choice;
            var prev_value = set_arg_state(id, value);
            if (prev_value == value) {
              return;
            }
            var elem = $("#command-line");
            var cl = elem.val();
            var reg = /\s+/;
            cl = cl.replace(reg, " ");
            if (cl.indexOf(id + " " + prev_value) != -1) {
               cl = cl.replace(id + " " + prev_value, id + ' ' + value);
            } else {
               cl = id + ' ' + value + ' ' + cl;
            }
            elem.val(cl);
            $("#command-line").trigger("change");
          }

          function get_diff(obj1, obj2) {
            var result = {};
            var keys_result = Object.keys(obj1).concat(Object.keys(obj2));
            for (var ind in keys_result) {
              var key = keys_result[ind];
              var ok1 = obj1[key];
              var ok2 = obj2[key];
              if (ok1 == undefined && ok2 != undefined) {
                result[key] = "created";
              } else if (ok1 != undefined && ok2 == undefined) {
                result[key] = "deleted";
              } else if (ok1 != undefined && ok2 != undefined && ok1 == ok2) {
                result[key] = "unchanged";
              } else {
                result[key] = "updated";
              }
            }
            return result;
          }

          function parse_cl(cl) {
            var args = minimist_parse(cl.split(/\s+/), opts);
            var positional = args["_"];
            var config_list = [];
            var positional_opts = {% raw positional_opts %};
            if (positional.length <= positional_opts.length) {
              for (var ind in positional) {
                args[positional_opts[ind]] = positional[ind];
              }
            }
            else {
              for (var ind in positional) {
                if (positional_opts[ind] != undefined && (ind != positional_opts.length - 1)) {
                  args[positional_opts[ind]] = positional[ind];
                } else {
                  config_list.push(positional[ind]);
                  args[positional_opts[positional_opts.length - 1]] = config_list;
                }
              }
            }
            delete args["_"];
            return args;
          }

          function from_args_to_states(args, states) {
            var positional_opts = {% raw positional_opts %};
            $.each(args, function(opt, arg) {
              if ($.inArray(opt, positional_opts) != -1) {
                states[opt] = arg;
              } else {
                  if (opts["alias"][opt] == undefined) {
                    opt_str = "--" + opt;
                    states[opt_str] = arg;
                  }
              }
            });
            return states;
          }

          function build_switch_regexp(id) {
            return new RegExp("(\\s|^)" + id + "(\\s|$)");
          }

          function set_arg_state(id, value) {
            var previous_value = cmdline_states[id];
            cmdline_states[id] = value;
            return previous_value;
          }

          function change_cl_by_input(cl, prev_value, value, id) {
            function generate_tail(id, value, wf, config, config_list) {
              var kwargs = {"workflow": 0, "config": 1, "config_list": 2};
              var tail = [].slice.call(arguments, 2);
              return tail.join(" ");
            }

            function cl_tail(wf, config, config_list) {
              return [].filter.call(arguments, function(s) { return s }).join(" ");
            }

            var positional_opts = {% raw positional_opts %};
            var wf = cmdline_states["workflow"];
            var config = cmdline_states["config"];
            var config_list = cmdline_states["config_list"];
            if ($.inArray(id, positional_opts) == -1) {
              if (cl.indexOf(id + " " + prev_value) != -1) {
                cl = cl.replace(id + " " + prev_value, id + ' ' + value);
              } else {
                cl = id + ' ' + value + ' ' + cl;
              }
            } else {
              var tail = cl_tail(wf, config, config_list);
              var new_tail = generate_tail(id, value, wf, config, config_list);
              if (cl.indexOf(prev_value) != -1) {
                cl = cl.replace(prev_value, value);
              } else {
                if (cl.indexOf(tail) != -1) {
                  cl = cl.replace(tail, new_tail);
                } else {
                    cl += " " + value;
                }
              }
            }
            return cl;
          }

          // This function modified command line for each change of value of widgets: input, switch, typeahead.
          // Also it modified value of widgets for each change of command line.
          $(function() {
              // This event changes value of option and value of command line if value of input has been changed.
              $("input:not(#command-line)").on("change", function() {
                var id = this.id;
                var value = this.value;
                var prev_value = set_arg_state(id, value);
                if (prev_value == value) {
                  return;
                }
                var elem = $("#command-line");
                var cl = elem.val();
                var reg = /\s+/;
                cl = cl.replace(reg, " ");
                cl = change_cl_by_input(cl, prev_value, value, id);
                elem.val(cl);
                $("#command-line").trigger("change");
              });
              // This event changes value of option and value of command line if switch has been switched.
              $(".switch").bootstrapSwitch().on('switchChange.bootstrapSwitch', function(event, state) {
                var id = this.id;
                var value = state;
                var prev_value = set_arg_state(id, value);
                if (prev_value == value) {
                  return;
                }
                var elem = $("#command-line");
                var cl = elem.val();

                var aid = "-" + alias_reversed[id.substring(2)];
                if (value) {
                  if (!aid || !cl.match(build_switch_regexp(aid))) {
                    cl = id + ' ' + cl;
                  }
                } else {
                  cl = cl.replace(build_switch_regexp(id), '');
                  if (aid) {
                    cl = cl.replace(build_switch_regexp(aid), '');
                  }
                }
                elem.val(cl);
                $("#command-line").trigger("change");
              });
              // This event changes value of option and value of command line if workflow was chosen.
              $('.typeahead').on('typeahead:selected', function(event, value) {
                var selected_wf = value;
                var prev_wf = cmdline_states["workflow"];
                var wf = selected_wf["value"];
                var config = cmdline_states["config"];
                var spase = " ";
                var config_list = cmdline_states["config_list"];
                if (config == undefined) {
                  config = "";
                  space = "";
                }
                if (config_list == undefined) {
                  config_list = "";
                  space = "";
                }
                cmdline_states["workflow"] = wf;
                var elem = $("#command-line");
                var cl = elem.val();
                var reg = /\s+/;
                cl = cl.replace(reg, " ");
                if (cl.indexOf(prev_wf) != -1) {
                  cl = cl.replace(prev_wf, wf);
                } else {
                  var conf_str = config + space + config_list;
                  if (cl.indexOf(config + space + config_list) != -1) {
                    cl = cl.replace(config + space + config_list, wf + " " + conf_str);
                  } else {
                    cl += wf;
                  }
                }
                elem.val(cl);
                $("#command-line").trigger("change");
              });
              // This event changes value of widgets for each change of command line.
              $("#command-line").on("change", function() {
                $("#error-message").css("display", "none");
                var command_line = $("#command-line").val();
                var args = parse_cl(command_line);
                var defaults = {% raw defaults_opt %};
                var prev_cmdline_states = {};
                $.each(cmdline_states, function(opt, arg) {
                  prev_cmdline_states[opt] = arg;
                  opt_for_arg = opt.replace(/^-+/, "");
                  if (args[opt_for_arg] == undefined) {
                    cmdline_states[opt] = defaults[opt];
                  }
                });
                cmdline_states = from_args_to_states(args, cmdline_states);
                var diff = get_diff(prev_cmdline_states, cmdline_states);
                for (var option in diff) {
                  var status_arg = diff[option];
                  var arg = cmdline_states[option];
                  var choices = {% raw choices %};
                  var elem_opt = $("#" + option);
                  if (status_arg == "unchanged" || status_arg == "deleted") {
                    continue;
                  }
                  if (status_arg == "created" || status_arg == "updated") {
                    if (elem_opt.hasClass("switch")) {
                      if (arg === false) {
                        elem_opt.bootstrapSwitch('state', false);
                      } else {
                        elem_opt.bootstrapSwitch('state', true);
                      }
                    }
                    if (elem_opt.hasClass("typeahead") || (elem_opt.hasClass("form-control") && !(elem_opt.hasClass("typeahead")))) {
                      elem_opt.val(arg);
                    }
                    if (elem_opt.hasClass("dropdown-menu")) {
                      var elem = $("#dropdown_menu" + option)
                        if ($.inArray(arg, choices[option]) != -1) {
                          elem.get(0).firstChild.nodeValue = arg;
                        } else {
                          $("#error-message").text("Wrong value of " + option + ". You should choose from " + choices[option]);
                          $("#error-message").css("display", "block");
                        }
                    }
                    if (!(elem_opt.hasClass("switch")) && !(elem_opt.hasClass("form-control")) &&
                        !(elem_opt.hasClass("dropdown-menu")) && $.inArray(option, {% raw special_opts %}) == -1) {
                      $("#error-message").text("Wrong option " + option);
                      $("#error-message").css("display", "block");
                    }
                    for (var key in opts.alias) {
                      if (command_line.match(build_switch_regexp("-" + key)) &&
                          command_line.match(build_switch_regexp("--" + opts.alias[key]))) {
                        $("#error-message").text("Duplicate option: --" + opts.alias[key]);
                        $("#error-message").css("display", "block");
                      }
                    }
                  }
                }
              });
          });

          function run() {
            $.ajax({
              url: "cmdline",
              type: "POST",
              data: JSON.stringify({cmdline: $("#command-line").val()}),
              contentType: "application/json; charset=utf-8",
              async: true,
              success: function(result) {
                window.close();
              }
            });
          }
       </script>
    </body>
</html>
